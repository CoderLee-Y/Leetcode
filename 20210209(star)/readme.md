# 题目
给定一个正整数数组 A，如果 A 的某个子数组中不同整数的个数恰好为 K，则称 A 的这个连续、不一定独立的子数组为好子数组。

（例如，[1,2,3,1,2] 中有 3 个不同的整数：1，2，以及 3。）

返回 A 中好子数组的数目。
*示例 1：*
输入：A = [1,2,1,2,3], K = 2
输出：7
解释：恰好由 2 个不同整数组成的子数组：[1,2], [2,1], [1,2], [2,3], [1,2,1], [2,1,2], [1,2,1,2].
*示例 2：*
输入：A = [1,2,1,3,4], K = 3
输出：3
解释：恰好由 3 个不同整数组成的子数组：[1,2,1,3], [2,1,3], [1,3,4].

# 双指针？
回顾过去，做的双指针问题主要聚焦于“最小”“最大”“最长”这样的问题上，而这道题用的是“总数”，所以说可能用双指针还会出现一定障碍。
如果本题询问的是，最多包含K种不同整数的子区间的个数，那么我们用双指针就可以做出来，先把left，right标出，right向右移动，若不能满足要求则移动left，直到求出所有最多包含k种不同整数的子区间个数A(K)，而本题答案便是A(K)-A(K-1)。

# 技术性难点
如何知道现在已经有几个不同的数字呢？这需要对数据结构的熟悉。很容易想到用HASH来处理：对于一个新数字，带入HASH，更新后计算HASH表规模即可知道。很显然不需要顺序，则可以用unordered_map来处理。

# 计数性难点
小于K个不同整数的子数组个数怎么统计？比如现在我发现0-6合格了，那么无疑0-6，1-6……5-6都合格，应该+6，即right-left。而且每到一个合格点都应该ans+=right-left.即0-1，0-2……0-5都应该算入。如果left发生了右移，很容易想到如果right不需要左移，right左移left右移的一定已经统计好了的。