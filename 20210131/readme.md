# 题意
如果交换字符串 X 中的两个不同位置的字母，使得它和字符串 Y 相等，那么称 X 和 Y 两个字符串相似。如果这两个字符串本身是相等的，那它们也是相似的。

例如，"tars" 和 "rats" 是相似的 (交换 0 与 2 的位置)； "rats" 和 "arts" 也是相似的，但是 "star" 不与 "tars"，"rats"，或 "arts" 相似。

总之，它们通过相似性形成了两个关联组：{"tars", "rats", "arts"} 和 {"star"}。注意，"tars" 和 "arts" 是在同一组中，即使它们并不相似。形式上，对每个组而言，要确定一个单词在组中，只需要这个词和该组中至少一个单词相似。

给你一个字符串列表 strs。列表中的每个字符串都是 strs 中其它所有字符串的一个字母异位词。请问 strs 中有多少个相似字符串组？

# 解法
本题考察的是并查集。理由是任意字符串能归集到一个字符串组，只需要和该组任何一个相似即可。
如何判断两个字符串是不是ANAGRAM？方法是直接逐一对比，时间复杂度是ON，如果是两个字母不同则可以，否则不行

# 复杂度分析
时间复杂度：
最坏情况下，我们需要n^2次对比，每次对比消耗m（字符串长度）的时间。并查过程中最坏需要nlogn的时间。
空间复杂度:O(n),其中n是字符串的数量.并查集需要O(n)的空间。

# 代码
    return f[x] == x ? x : f[x] = find(f[x]);
    //并查集的find函数优化
    //Vectors are sequence containers representing 
      arrays that can change in size.
    