# 题目
中位数是**有序序列**最中间的那个数。如果序列的长度是偶数，则没有最中间的数；此时中位数是最中间的两个数的平均数。

例如：

[2,3,4]，中位数是 3
[2,3]，中位数是 (2 + 3) / 2 = 2.5
给你一个数组 nums，有一个长度为 k 的窗口从最左端滑动到最右端。窗口中有 k 个数，每次窗口向右移动 1 位。你的任务是找出每次窗口移动后得到的新窗口中元素的中位数，并输出由它们组成的数组。

示例：
给出 nums = [1,3,-1,-3,5,3,6,7]，以及 k = 3。
[见相关网页](https://leetcode-cn.com/problems/sliding-window-median/)

# 分析
sliding windows month? 202102
关键显然是有序序列，怎样在有序序列中快速排序找到中位数是本题最大的难点。你需要的是一个优秀的数据结构来做存储+排序的功夫。
我们将这个数据结构的抽象类提取出来，需要：
- insert 滑动窗口中的加入新值
- erase 滑动窗口中的减少旧值
- median 求现在的中位数

# 方法一：双优先队列 + 迟删除
一个即时排序队列我们肯定会想到priority queue.但是问题是priority queue只能保证最值是有序的。那我们就想到删除若干最值找到中位数，那么到滑动窗口环节，我们有三情况：
- 旧值小于中位数，新的也小于 or 旧值大于中位数，新的也大于 ~中位数不变
- 与上个情况相反，新旧不再一边 ~需要继续从堆中删除 or 需要找回删除的值
- 和中位数一样。
  
所以我们的删除不能是“真删除”，只能是“迟删除”

详细叙述一下代码：
- 维护两个堆，一个large一个small，大根堆放较小的一半（向下取整），小根堆放较大的一半，向上取整。两个堆元素个数的关系为：
1. 元素个数相等，此时中位数为两个堆堆顶的平均值。
2. 小根堆多一个，此时中位数为小根堆堆顶的元素。

至此，median的思路已经完成。
- 对于insert，我们要看输入进来的这个元素。如果比大根堆顶小，就放进大根堆顶，如果比小根堆顶还大，就放到小根堆顶。然后看看是否符合要求。如果符合要求，则完成，否则：
1. 大根堆元素个数大于小根堆，那就把大根堆的堆顶元素出堆，放进小的。
2. 小根堆元素大于大根堆2个，那就把小根堆顶元素出栈，放进大根。

至此，Insert思路已经完成。

- 对于erase，难度会高很多。因为堆不支持删除非堆顶的元素。这时有一个非常巧妙地办法，叫做迟删除。这种删除方法在hash中意味着状态，在这里则是一种“告知”的删除方式。

>当我们需要移出优先队列中的某个元素时，我们只将这个删除操作「记录」下来，而不去真的删除这个元素。当这个元素出现在small或者large的堆顶时，我们再去将其移出对应的优先队列。


**我们维护一个hash表，键值对记为(a,b)表示a元素还有b次可删除。这是因为我们需要考虑重复的元素。**
思路已经全部清晰，这时候我们需要考虑怎么写代码能让这些功能尽可能的清晰。
我们先抽象一个函数prune(heap)来保证heap的堆顶不是一个b==0的值，并且维护hash。
再集成一个功能，makebalance保证二堆之间数目的合法性，并且在改变堆后及时prune。
这时，原来的Insert就只需要最后改变一下，变成makebalance即可。
但是现在有个问题，我们保证的元素个数合法性，必须得是“真实个数”，也即是说我们需要专门维护以下两个堆的个数。

# unordered map 
因为内部实现了哈希表，因此其查找速度非常的快，对于查找问题，unordered_map会更加高效一些，因此遇到查找问题，常会考虑一下用unordered_map。