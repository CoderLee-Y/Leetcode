# 题目
给定一个非负索引 k，其中 k ≤ 33，返回杨辉三角的第 k 行。

在杨辉三角中，每个数是它左上方和右上方的数的和。

*示例:*
输入: 3
输出: [1,3,3,1]
**进阶：**
**你可以优化你的算法到 O(k) 空间复杂度吗？**

# 解法
暴力开数组，时间前75%，空间前5%，不禁让人有些疑惑……
代码如main.cpp

# 官解1
很显然要求OK那就是要有数学解...那么答案是：第K行（从1开始编号，编程时注意转换）从1变大再变小是从Cn1->Cnn的转变。而杨辉三角的叠加性质也正是组合数的重要：N球选X个，正如N球选1个再加上N-1球选X-1个。
注意：要给一个vector赋值有两法，其一，先resize(n)，再用vec[i]来访问，其二push_back().

# 优化1
先对你写的代码做一个空间优化：滚动数组法。这样可以避免开一个二维数组。
同时，别再傻傻的来a[34][34]这样去赋值了，做一个动态的数组vector<vector<int>> a;不香？
当然，最简单还是用俩vector……这叫滚动数组。

# 优化2
我们发现上一行的数据也不是全部有用！我们倒着来算，当前ij只和i-1j-1 & i-1j有关，那我们直接倒过来替换就行。这是极致的空间压缩。

# 官解2
发现了一个递推公式。CNM=CN(M-1)+(N-M+1)/M,这显然简单不少。这种解法均为前1%，再次证明了数学推导在解题的极端重要性...